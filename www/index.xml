<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>豆瓣坛</title>
<link>https://adopapa.cc/</link>
<atom:link href="https://adopapa.cc/index.xml" rel="self" type="application/rss+xml"/>
<description>唯有写字可以解忧</description>
<generator>quarto-1.5.57</generator>
<lastBuildDate>Mon, 30 Sep 2024 11:27:38 GMT</lastBuildDate>
<item>
  <title>tbd</title>
  <dc:creator>Adopapa </dc:creator>
  <link>https://adopapa.cc/posts/rlang/how-to-install-packages-through-cranmirrors/</link>
  <description><![CDATA[ 




<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">install.packages</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"magick"</span>)</span></code></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>The following package(s) will be installed:
- magick [2.8.5]
These packages will be installed into "~/Documents/writer/adopapablog/renv/library/macos/R-4.4/aarch64-apple-darwin20".

# Installing packages --------------------------------------------------------
- Installing magick ...                         OK [linked from cache]
Successfully installed 1 package in 5 milliseconds.</code></pre>
</div>
</div>
<p>在 R 中，如果遇到下载超时的问题，可以尝试增加超时时间来解决。可以通过以下几种方式增加超时时间：</p>
<p>使用 options() 函数全局设置超时时间： 可以将全局超时时间设置为比默认值更长的时间，例如 300 秒： options(timeout = 300) install.packages(“magick”) 在 install.packages() 中直接指定超时时间： 有些函数调用支持 timeout 参数，可以直接在函数中指定： install.packages(“magick”, timeout = 300) 检查网络连接的稳定性： 确保你的网络连接稳定，有时候不稳定的网络可能会导致下载中断。尝试在网络状况较好的时候进行下载。 选择镜像： 有时 CRAN 镜像问题也会导致下载失败，可以尝试选择一个更稳定的 CRAN 镜像： chooseCRANmirror() install.packages(“magick”) 通过这些方法，你应该能够下载和安装 magick 包。如果问题依然存在，可以考虑直接下载二进制文件，然后手动安装。 可否在install.packages中直接指定一个或几个镜像？</p>
<p>GPT-4o 在 R 中使用 install.packages() 函数时，可以通过 repos 参数直接指定一个或多个CRAN镜像。这样可以确保从指定的镜像下载软件包。以下是如何指定一个或多个镜像的例子：</p>
<p>指定一个镜像： install.packages(“magick”, repos = “https://cran.rstudio.com/”) 指定多个镜像（R 将会依次尝试使用这些镜像）： install.packages(“magick”, repos = c(“https://cran.rstudio.com/”, “https://cloud.r-project.org/”)) 通过设置 repos 参数，你可以直接控制软件包的下载来源，选择速度更快或更稳定的镜像。 请给我提供全部76个镜像的相关网站链接</p>
<p>GPT-4o CRAN（Comprehensive R Archive Network）在全球范围内有多个镜像站点。这里通常有大约76个官方镜像，虽然它们可能会根据时间的推移有一些变动。以下提供了一些主要的CRAN镜像链接。请注意，实际的可用数量可能会有所改变，建议访问CRAN镜像页面以获取最新信息。</p>
<p>Austria: https://cran.wu.ac.at/ Australia: https://cran.csiro.au/ Brazil: https://cran.fiocruz.br/ Canada: https://cran.ca.r-project.org/ China: https://mirrors.tuna.tsinghua.edu.cn/CRAN/ Germany: https://cran.uni-muenster.de/ India: https://cran.iitk.ac.in/ Japan: https://cran.ism.ac.jp/ Russia: https://cran.astranet.ru/ South Africa: https://cran.r-project.org.za/ United Kingdom: https://cran.ma.imperial.ac.uk/ United States (RStudio): https://cran.rstudio.com/ 这些列出的只是部分镜像，你可以通过运行以下R代码来获取CRAN的所有可用镜像列表：</p>
<p>available.packages(repos=“https://cran.r-project.org”) -&gt; ap ap[1:10] # This will display the first 10 entries with various MIRRORS for package access 或者，访问CRAN的官方网站，选择”CRAN Mirrors”页面以查看完整的镜像列表：</p>
<p>CRAN Mirrors List 此页面将包含最新的和完整的镜像列表，确保提供最准确和及时的信息。</p>



 ]]></description>
  <category>tbd</category>
  <category>tbd</category>
  <category>tbd</category>
  <category>tbd</category>
  <guid>https://adopapa.cc/posts/rlang/how-to-install-packages-through-cranmirrors/</guid>
  <pubDate>Mon, 30 Sep 2024 11:27:38 GMT</pubDate>
</item>
<item>
  <title>海棠果热成了红苹果</title>
  <dc:creator>Adopapa </dc:creator>
  <link>https://adopapa.cc/posts/diary/lastdayofaugust.html</link>
  <description><![CDATA[ 




<p>红扑扑的，如果不说，你会以为是苹果吧。</p>
<p>这只是公司园区里的海棠果。三十多年了，其实我很难注意到他们，其一，它们往年的身材较小，比大枣也大不了多少，其二，每年他们都是被浓密的绿叶遮挡住了，不仔细看，很容易只见绿叶不见绿果。今年带劲的天气(42.4度)给了他们疯狂生长的信号，叶子也脱落殆尽，让你没法忽略那个庞大的果子存在。</p>
<p><img src="https://adopapa.cc/posts/diary/images/IMG_4537.png" class="img-fluid"></p>
<p>想起在新加坡的滨海花园(Garden by the Bay)的云雾森林(Clouds Forest)里一起看全球气候变化的电影(看样子是2010年拍的)。电影预测2100年全球的平均温度会上升5度左右。这是基于继续高排放情况下的预测，但我估计这是比较可能的结果，甚至是比较乐观的结果，毕竟人类的天性你懂的)。</p>
<p>出了门，我半沉重半开玩笑地对儿子说，祝你2114的百岁身躯可以抵挡得住那股热浪吧，儿子大笑。</p>
<p><img src="https://adopapa.cc/posts/diary/images/FA64D6FA-273E-48D8-B137-AA1AA8DDF3D0_1_105_c.jpeg" class="img-fluid"></p>
<p>2024-08-30 12:49:36</p>



 ]]></description>
  <category>随记</category>
  <category>气候</category>
  <category>植物</category>
  <guid>https://adopapa.cc/posts/diary/lastdayofaugust.html</guid>
  <pubDate>Fri, 30 Aug 2024 04:25:25 GMT</pubDate>
</item>
<item>
  <title>tbd</title>
  <dc:creator>Adopapa </dc:creator>
  <link>https://adopapa.cc/posts/backend/how-to-install-docker-in -ubuntu22/</link>
  <description><![CDATA[ 




<section id="缘起" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="缘起"><span class="header-section-number">1</span> 缘起</h2>
<p>博客通过docker+nginx部署上了，但是只能内网访问，ufw检查了没问题，于是怀疑ubuntu上的docker可能版本不对</p>
</section>
<section id="那就来出现安装了" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="那就来出现安装了"><span class="header-section-number">2</span> 那就来出现安装了</h2>
<p>kimi看了十篇网文，于是给我提供了docker安装的最佳实践</p>
</section>
<section id="docker-desktop-or-docker-engine" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="docker-desktop-or-docker-engine"><span class="header-section-number">3</span> docker-desktop or docker engine</h2>
<p>docker-enginge，所以docker-desktop并不需要</p>
</section>
<section id="kimi-ref" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="kimi-ref"><span class="header-section-number">4</span> kimi ref</h2>
<p>在Ubuntu 22.04上安装Docker和Docker Compose的最佳实践通常包括以下步骤：</p>
<ol type="1">
<li><p><strong>更新系统包</strong>：首先，确保你的Ubuntu系统是最新的。可以通过执行以下命令来更新： <code>sudo apt update sudo apt upgrade</code><sup>1</sup></p></li>
<li><p><strong>卸载旧版本的Docker</strong>（如果已安装）：在安装新版本的Docker之前，需要先卸载旧版本的Docker。可以使用以下命令： <code>sudo apt-get remove docker docker-engine docker.io containerd runc</code><sup>2</sup> :::{tips} 提示：无docker-engine :::</p></li>
<li><p><strong>安装依赖项</strong>：安装Docker所需的依赖项，包括HTTPS传输、CA证书、curl、软件属性通用包、GnuPG等： <code>sudo apt install apt-transport-https ca-certificates curl software-properties-common gnupg lsb-release</code><sup>3</sup></p></li>
<li><p><strong>添加Docker的官方GPG密钥</strong>：这将确保你能够从Docker的官方源安装Docker。 <code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</code><sup>4</sup></p></li>
<li><p><strong>设置Docker的APT源</strong>：添加Docker的官方APT源，以便安装最新版本的Docker。 <code>echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</code><sup>5</sup></p></li>
<li><p><strong>再次更新APT源</strong>：更新本地APT源列表，确保可以安装最新版本的Docker。 <code>sudo apt update</code><sup>6</sup></p></li>
<li><p><strong>安装Docker Engine和Docker Compose</strong>：安装Docker Engine和Docker Compose。从Ubuntu 22.04开始，Docker Compose作为Docker Engine的一部分被包含在内，所以只需安装Docker Engine即可。 <code>sudo apt install docker-ce docker-ce-cli containerd.io docker-compose-plugin</code><sup>7</sup></p></li>
<li><p><strong>验证安装</strong>：验证Docker和Docker Compose是否正确安装并运行： <code>sudo docker version docker-compose --version</code><sup>8</sup></p></li>
<li><p><strong>配置镜像加速</strong>（可选）：如果你在中国大陆使用Docker，可能需要配置镜像加速以提高拉取镜像的速度。可以编辑<code>/etc/docker/daemon.json</code>文件，添加以下内容：</p>
<pre><code>{
  "registry-mirrors": ["https://registry.docker-cn.com"]
}</code></pre>
<p>然后重启Docker服务： <code>sudo systemctl daemon-reload sudo systemctl restart docker</code><sup>9</sup></p></li>
<li><p><strong>运行Docker Hello World测试</strong>：运行Docker的Hello World测试，以确保Docker正确安装并运行： <code>sudo docker run hello-world</code><sup>10</sup></p></li>
</ol>
<p>这些步骤提供了一个基本的指南，以确保在Ubuntu 22.04上安装Docker和Docker Compose的最佳实践。记得在执行这些步骤之前，你有足够的权限（通常是root权限或使用sudo）。</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>2^↩︎</p></li>
<li id="fn2"><p>1^↩︎</p></li>
<li id="fn3"><p>2^↩︎</p></li>
<li id="fn4"><p>1^↩︎</p></li>
<li id="fn5"><p>1^↩︎</p></li>
<li id="fn6"><p>2^↩︎</p></li>
<li id="fn7"><p>2^↩︎</p></li>
<li id="fn8"><p>2^↩︎</p></li>
<li id="fn9"><p>6^↩︎</p></li>
<li id="fn10"><p>2^↩︎</p></li>
</ol>
</section></div> ]]></description>
  <category>tbd</category>
  <category>tbd</category>
  <category>tbd</category>
  <category>tbd</category>
  <guid>https://adopapa.cc/posts/backend/how-to-install-docker-in -ubuntu22/</guid>
  <pubDate>Mon, 01 Jul 2024 13:38:46 GMT</pubDate>
</item>
<item>
  <title></title>
  <dc:creator>adopapa </dc:creator>
  <link>https://adopapa.cc/posts/quarto/quarto-yaml-options/</link>
  <description><![CDATA[ 




<section id="keywords和category有何不同" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="keywords和category有何不同"><span class="header-section-number">1</span> keywords和category有何不同？</h2>
</section>
<section id="节外生枝" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="节外生枝"><span class="header-section-number">2</span> 节外生枝</h2>
<p><code>quarto render</code> 报错已大堆</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://adopapa.cc/posts/quarto/quarto-yaml-options/images/render-erro.png" class="img-fluid figure-img"></p>
<figcaption>render时的一大堆报错</figcaption>
</figure>
</div>
<p>仔细一看源文件，讯飞鼠标神不知鬼不觉地把我的呼吸变成了一个 <code>的</code> 贴到了yaml设置里了。</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://adopapa.cc/posts/quarto/quarto-yaml-options/images/why-error.png" class="img-fluid figure-img"></p>
<figcaption>哪里来的的</figcaption>
</figure>
</div>


</section>

 ]]></description>
  <category>Quarto YAML</category>
  <guid>https://adopapa.cc/posts/quarto/quarto-yaml-options/</guid>
  <pubDate>Sun, 30 Jun 2024 08:45:28 GMT</pubDate>
</item>
<item>
  <title>自己的地盘，自己看着点</title>
  <dc:creator>Adopapa </dc:creator>
  <link>https://adopapa.cc/posts/ubuntu22/how-to-monitor-linux-server-ubuntu/</link>
  <description><![CDATA[ 




<section id="起子" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="起子"><span class="header-section-number">1</span> 起子</h2>
<p>习惯登录之后看一下系统显示提醒信息，这不前两天的一个僵尸进程可吓了我一跳(参见<a href="../../../posts/backend/how-to-clean-zombie-process/index.html">僵尸进程的处理</a>。于是觉得提升一点监控级别还是有必要的。大厂让人眼花缭乱的监控，可不还是各种开源软件的组合吗？自己也可以动起来。</p>
</section>
<section id="先来一个-neofetch" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="先来一个-neofetch"><span class="header-section-number">2</span> 先来一个 neofetch</h2>
<p>有事问AI, 尽管其会胡说八道，但是确实一个线索的重要提供者，在于计算机类的信息还是以个蛮不错的开始。爱</p>
<p><img src="https://adopapa.cc/posts/ubuntu22/how-to-monitor-linux-server-ubuntu/images/neofetch.png" class="img-fluid"></p>
</section>
<section id="ai的推荐-存档" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="ai的推荐-存档"><span class="header-section-number">3</span> AI的推荐-存档</h2>
<p>在 Ubuntu 服务器上，通过 SSH 登录后显示更多的健康监控指标，可以帮助管理员快速了解系统状态。以下是几种配置方法和工具，可用于增强服务器健康监控：</p>
<section id="方法一修改-motdmessage-of-the-day" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="方法一修改-motdmessage-of-the-day"><span class="header-section-number">3.1</span> <strong>方法一：修改 MOTD（Message of the Day）</strong></h3>
<p>Ubuntu 在用户登录时显示 MOTD（消息每日通告），可以通过配置 MOTD 来显示系统健康监控指标。</p>
<section id="配置-motd" class="level4" data-number="3.1.1">
<h4 data-number="3.1.1" class="anchored" data-anchor-id="配置-motd"><span class="header-section-number">3.1.1</span> 配置 MOTD</h4>
<ol type="1">
<li><p><strong>通过 Landscape 提供的 MOTD（默认）</strong>：</p>
<p>默认情况下，Ubuntu 服务器使用 <code>landscape-sysinfo</code> 生成 MOTD 信息。你可以通过编辑<code>/etc/update-motd.d</code>中的文件来自定义登录信息。</p>
<pre><code>sudo nano /etc/update-motd.d/00-header  # 添加定制的 header
sudo nano /etc/update-motd.d/10-sysinfo  # 定制系统信息</code></pre></li>
<li><p><strong>添加自定义脚本</strong>：</p>
<p>你可以创建和添加自定义脚本来显示系统健康信息。在<code>/etc/update-motd.d/</code>目录中添加一个新的脚本文件，如：</p>
<pre><code>sudo nano /etc/update-motd.d/20-healthcheck</code></pre>
<p>在这个脚本中添加你希望显示的信息。例如，下面是一个示例脚本，用于显示系统负载、磁盘使用情况和内存使用情况：</p>
<pre><code>#!/bin/bash
echo "System Load: $(uptime)"
echo "Disk Usage:"
df -h | grep '^/dev/'
echo "Memory Usage:"
free -h</code></pre>
<p>确保脚本具有执行权限：</p>
<pre><code>sudo chmod +x /etc/update-motd.d/20-healthcheck</code></pre></li>
<li><p><strong>更新并查看效果</strong>：</p>
<p>断开 SSH 会话并重新登录，查看新的 MOTD 信息。</p></li>
</ol>
</section>
</section>
<section id="方法二使用-screenfetch-或-neofetch" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="方法二使用-screenfetch-或-neofetch"><span class="header-section-number">3.2</span> <strong>方法二：使用 <code>screenfetch</code> 或 <code>neofetch</code></strong></h3>
<p><code>screenfetch</code> 和 <code>neofetch</code> 是两个广受欢迎的工具，用于在登录时显示系统信息。</p>
<section id="安装-neofetch" class="level4" data-number="3.2.1">
<h4 data-number="3.2.1" class="anchored" data-anchor-id="安装-neofetch"><span class="header-section-number">3.2.1</span> <strong>安装 <code>neofetch</code></strong></h4>
<ol type="1">
<li><p><strong>安装 neofetch</strong>：</p>
<pre><code>sudo apt update
sudo apt install neofetch</code></pre></li>
<li><p><strong>配置 Shell 配置文件</strong>：</p>
<p>编辑对应的 shell 配置文件（如 <code>.bashrc</code> 或 <code>.zshrc</code>），使其在登录时自动运行 <code>neofetch</code>：</p>
<pre><code>echo "neofetch" &gt;&gt; ~/.bashrc
source ~/.bashrc</code></pre></li>
</ol>
</section>
<section id="安装-screenfetch" class="level4" data-number="3.2.2">
<h4 data-number="3.2.2" class="anchored" data-anchor-id="安装-screenfetch"><span class="header-section-number">3.2.2</span> <strong>安装 <code>screenfetch</code></strong></h4>
<ol type="1">
<li><p><strong>安装 screenfetch</strong>：</p>
<pre><code>sudo apt update
sudo apt install screenfetch</code></pre></li>
<li><p><strong>配置 Shell 配置文件</strong>：</p>
<p>编辑对应的 shell 配置文件（如 <code>.bashrc</code> 或 <code>.zshrc</code>），使其在登录时自动运行 <code>screenfetch</code>：</p>
<pre><code>echo "screenfetch" &gt;&gt; ~/.bashrc
source ~/.bashrc</code></pre></li>
</ol>
</section>
</section>
<section id="方法三使用-glances-实时监控" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="方法三使用-glances-实时监控"><span class="header-section-number">3.3</span> <strong>方法三：使用 <code>glances</code> 实时监控</strong></h3>
<p><code>glances</code> 是一个多功能系统监控工具，支持查看多种系统性能指标。</p>
<section id="安装-glances" class="level4" data-number="3.3.1">
<h4 data-number="3.3.1" class="anchored" data-anchor-id="安装-glances"><span class="header-section-number">3.3.1</span> <strong>安装 <code>glances</code></strong></h4>
<pre><code>sudo apt update
sudo apt install glances</code></pre>
</section>
<section id="使用-glances" class="level4" data-number="3.3.2">
<h4 data-number="3.3.2" class="anchored" data-anchor-id="使用-glances"><span class="header-section-number">3.3.2</span> <strong>使用 <code>glances</code></strong></h4>
<p>安装完成后，可以通过以下命令启动 <code>glances</code>，实时显示系统状态：</p>
<pre><code>glances</code></pre>
</section>
<section id="配置自动启动" class="level4" data-number="3.3.3">
<h4 data-number="3.3.3" class="anchored" data-anchor-id="配置自动启动"><span class="header-section-number">3.3.3</span> <strong>配置自动启动</strong></h4>
<p>可以在shell配置文件中添加命令来运行 <code>glances</code>，例如在 <code>.bashrc</code> 中：</p>
<pre><code>echo "glances" &gt;&gt; ~/.bashrc
source ~/.bashrc</code></pre>
</section>
</section>
<section id="高级监控工具" class="level3" data-number="3.4">
<h3 data-number="3.4" class="anchored" data-anchor-id="高级监控工具"><span class="header-section-number">3.4</span> <strong>高级监控工具</strong></h3>
<ol type="1">
<li><strong>Prometheus + Grafana</strong>：</li>
</ol>
<p>如果需要更强大的监控解决方案，可以考虑使用 Prometheus 和 Grafana。这两个工具组合可以提供实时系统监控、告警和丰富的仪表盘功能。</p>
<pre><code>- 安装 Prometheus 和 Grafana 的详细步骤可以参考官方文档。

- 配置节点导出器（Node Exporter）来收集系统指标。</code></pre>
<ol start="2" type="1">
<li><p><strong>Netdata</strong>：</p>
<p><code>Netdata</code> 也是一个强大的实时监控工具，支持详细的系统性能指标和告警功能。</p>
<pre><code># 安装 netdata（需要在官方文档中确认推荐的安装方式）
bash &lt;(curl -Ss https://my-netdata.io/kickstart.sh)</code></pre></li>
</ol>
<p>安装后的 <code>Netdata</code> 可以通过 Web 界面访问实时监控信息。</p>
</section>
</section>
<section id="section" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="section"><span class="header-section-number">4</span> </h2>


</section>

 ]]></description>
  <category>Linux</category>
  <category>Server</category>
  <category>Monitor</category>
  <guid>https://adopapa.cc/posts/ubuntu22/how-to-monitor-linux-server-ubuntu/</guid>
  <pubDate>Sun, 30 Jun 2024 08:14:12 GMT</pubDate>
</item>
<item>
  <title>自动化发布的初体验-本地发布</title>
  <dc:creator>Adopapa </dc:creator>
  <link>https://adopapa.cc/posts/quarto/publish-website-localhost-with-nginx-/</link>
  <description><![CDATA[ 




<section id="互联网平台的心思" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="互联网平台的心思"><span class="header-section-number">1</span> 互联网平台的心思</h2>
<p>像微信公众号这样的大平台居然没有一个像样的自动发布工具，我只能如此狭隘地以小人度之了。看来看去的平台供应商大抵是是恨不得把你的整个身心都圈禁到他们的平台，所有每天劳苦工作到喘息，让你根本没有思考的机会。自动化发布这种工具大概是与这种相违背的 - 岂不是给你it’s 16 hours更多兼职的机会吗？自动化是有有的，那是给大佬们收割打工人的，打工人人只能被眼前的自动诱惑，手动模式满心欢喜地冲向这个永远到达不了的圣地。</p>
<p>写公众号时断时续究竟还是自己的毛病，本就没有自己的内容，但是不能这样说啊，只能说每次枯燥的手动更新就让自己有一种作做奴隶的凄凉感，完全没有了新时代的自由人的感觉，要是你放弃了，就是自己自己的文章要拿回来也时间挺费事的事情，感觉比抄家还难受。</p>
<p>搬过过几次家，那种感觉确实是太难受了，搬一次就是要扔掉好多东西。写作也是如此，东西还是要放在自己的地盘上，然后是想发哪里就发哪里，而且还是能自动的就不要手动了。于是编程这事就是要成了必须要解决的问题了。</p>
</section>
<section id="我的选型" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="我的选型"><span class="header-section-number">2</span> 我的选型</h2>
<p>写作工具: Quarto 编辑器: Rstudio 部署工具: Docker，Ngnix，Ubuntu</p>
</section>
<section id="head2" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="head2"><span class="header-section-number">3</span> head2</h2>
</section>
<section id="head2-1" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="head2-1"><span class="header-section-number">4</span> head2</h2>


</section>

 ]]></description>
  <category>publish</category>
  <category>Quarto</category>
  <category>nginx</category>
  <category>docker</category>
  <guid>https://adopapa.cc/posts/quarto/publish-website-localhost-with-nginx-/</guid>
  <pubDate>Sun, 30 Jun 2024 07:39:40 GMT</pubDate>
</item>
<item>
  <title>如何给服务器起一个简洁好记的名字</title>
  <dc:creator>Adopapa </dc:creator>
  <link>https://adopapa.cc/posts/ubuntu22/how-to-change-the-hostname-in-ubuntu22/</link>
  <description><![CDATA[ 




<p>在Ubuntu中，修改服务器的主机名分为两部分：临时修改和永久修改。以下是如何进行这两种修改的具体步骤：</p>
<section id="一临时修改主机名" class="level3" data-number="0.1">
<h3 data-number="0.1" class="anchored" data-anchor-id="一临时修改主机名"><span class="header-section-number">0.1</span> <strong>一、临时修改主机名</strong></h3>
<p>临时修改主机名是不需要重启系统的，但该修改在重启后会失效。使用如下命令：</p>
<pre><code>sudo hostnamectl set-hostname tclh01</code></pre>
</section>
<section id="二永久修改主机名" class="level3" data-number="0.2">
<h3 data-number="0.2" class="anchored" data-anchor-id="二永久修改主机名"><span class="header-section-number">0.2</span> <strong>二、永久修改主机名</strong></h3>
<p>要确保重启后主机名依然被修改，我们需要修改两个文件：<code>/etc/hostname</code>&nbsp;和&nbsp;<code>/etc/hosts</code>。</p>
<ol type="1">
<li><p><strong>修改&nbsp;<code>/etc/hostname</code>&nbsp;文件</strong></p>
<p>&nbsp;</p>
<p>使用文本编辑器（如&nbsp;<code>nano</code>&nbsp;或&nbsp;<code>vi</code>）编辑该文件：</p>
<pre><code>sudo nano /etc/hostname</code></pre>
<p>将文件中的内容改为&nbsp;<code>tclh01</code>，保存并退出。</p></li>
<li><p><strong>修改&nbsp;<code>/etc/hosts</code>&nbsp;文件</strong></p>
<p>&nbsp;</p>
<p>同样使用文本编辑器修改&nbsp;<code>/etc/hosts</code>&nbsp;文件：</p>
<pre><code>sudo nano /etc/hosts</code></pre>
<p>找到包含旧主机名的行，并将其修改为新主机名&nbsp;<code>tclh01</code>，类似如下：</p>
<pre><code>127.0.0.1   localhost
127.0.1.1   tclh01</code></pre>
<p>请确保没有多余的空白行或格式错误，保存并退出。</p></li>
</ol>
</section>
<section id="三重启系统" class="level3" data-number="0.3">
<h3 data-number="0.3" class="anchored" data-anchor-id="三重启系统"><span class="header-section-number">0.3</span> <strong>三、重启系统</strong></h3>
<p>为了确保所有更改生效，建议重启系统：</p>
<pre><code>sudo reboot</code></pre>
</section>
<section id="小结" class="level3" data-number="0.4">
<h3 data-number="0.4" class="anchored" data-anchor-id="小结"><span class="header-section-number">0.4</span> <strong>小结</strong></h3>
<p>总结以上步骤，你可以按照如下命令序列操作：</p>
<pre><code># 临时修改主机名
sudo hostnamectl set-hostname tclh01

# 编辑 /etc/hostname 文件
sudo nano /etc/hostname
# 将内容改为 tclh01，保存退出

# 编辑 /etc/hosts 文件
sudo nano /etc/hosts
# 将相关行修改为 127.0.1.1   tclh01，保存退出

# 重启系统
sudo reboot</code></pre>
<p>完成这些步骤后，你的服务器主机名应已修改为&nbsp;<code>tclh01</code>，并能在重启后保持不变。</p>


</section>

 ]]></description>
  <category>linux</category>
  <category>ubuntu</category>
  <guid>https://adopapa.cc/posts/ubuntu22/how-to-change-the-hostname-in-ubuntu22/</guid>
  <pubDate>Sat, 29 Jun 2024 00:28:40 GMT</pubDate>
</item>
<item>
  <title>Excel函数之lookup, vlookup, xlookup</title>
  <dc:creator>adopapa </dc:creator>
  <link>https://adopapa.cc/posts/excel/lookup-vlookup-xlookup/</link>
  <description><![CDATA[ 




<p>前几天交流了一下自己经常用的vlookup,可以解决多个相关excel表的快速比对问题。</p>
<p>今天朋友问lookup更简单啊，为什么要vlookup，我就傻了，赶紧问ai结，论就是lookup只能单行匹配，而是只能近似匹配，这个不能满足我们的业务场景需求。</p>
<p>另外一个同事提出现在有了xlookup了，更加简单，结果大家找了一下，应该是比较新的版本里才有xlookup。和 vlookup想不比，xlookup可以查找行，获取任意列的返回，vlookup只能返回对比行右侧的行，一起的解决方案就是临时把查找行左侧的所需列复制插入查找行的右侧。</p>
<p>做了一个测试表格，对比lookup，vlookup，xlookup的查找效果。</p>
<p><img src="https://adopapa.cc/posts/excel/lookup-vlookup-xlookup/images/excel-lookup-test-02.png" class="img-fluid"></p>
<p><img src="https://adopapa.cc/posts/excel/lookup-vlookup-xlookup/images/excel-lookup-test-01.png" class="img-fluid"></p>
<p>excel的版本很多，每个人需要具体看看自己的版本里有这个公式没。用 起来吧，终于摆脱vlookup的限制和繁琐了。</p>



 ]]></description>
  <category>linux</category>
  <category>ubuntu</category>
  <guid>https://adopapa.cc/posts/excel/lookup-vlookup-xlookup/</guid>
  <pubDate>Fri, 28 Jun 2024 00:20:48 GMT</pubDate>
</item>
<item>
  <title>一不留神，僵尸就这么跳将进来了</title>
  <dc:creator>adopapa </dc:creator>
  <link>https://adopapa.cc/posts/backend/how-to-clean-zombie-process/</link>
  <description><![CDATA[ 




<p>看到系统信息中提到的僵尸进程（zombie process），尽管听起来可能有些令人担忧，但它并不一定意味着系统存在危险。不过，了解什么是僵尸进程以及如何处理它们是很重要的。</p>
<p><img src="https://adopapa.cc/posts/backend/how-to-clean-zombie-process/images/Screenshot 2024-06-28 at 08.17.31.png" class="img-fluid"></p>
<section id="什么是僵尸进程" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="什么是僵尸进程"><span class="header-section-number">1</span> <strong>什么是僵尸进程？</strong></h2>
<p>僵尸进程是在其执行完成后仍保留在进程表中的进程。这些进程已经终止，但其父进程还没有读取其退出状态，因此这些进程的资源尚未完全释放。它们占用的系统资源非常少，但积累太多的僵尸进程可能会耗尽系统可用的进程表条目。</p>
</section>
<section id="如何查找僵尸进程" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="如何查找僵尸进程"><span class="header-section-number">2</span> <strong>如何查找僵尸进程？</strong></h2>
<p>你可以使用&nbsp;<code>ps</code>&nbsp;命令来查找系统中的僵尸进程：</p>
<pre><code>ps aux | grep Z</code></pre>
<p><img src="https://adopapa.cc/posts/backend/how-to-clean-zombie-process/images/Screenshot 2024-06-28 at 08.21.22.png" class="img-fluid"></p>
<p>在输出中，你会看到带有&nbsp;<code>Z</code>&nbsp;状态码的进程，这些就是僵尸进程。</p>
</section>
<section id="处理僵尸进程的方法" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="处理僵尸进程的方法"><span class="header-section-number">3</span> <strong>处理僵尸进程的方法</strong></h2>
<section id="手动即时清理" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="手动即时清理"><span class="header-section-number">3.1</span> 手动即时清理</h3>
<ol type="1">
<li><p><strong>手动杀掉父进程</strong>： 找到僵尸进程的父进程ID (PPID)。你可以使用&nbsp;<code>ps</code>&nbsp;或&nbsp;<code>top</code>&nbsp;命令来查找其父进程。</p>
<pre><code>ps -o ppid= -p &lt;zombie_pid&gt;</code></pre>
<p>使用&nbsp;<code>kill</code>&nbsp;命令来结束该父进程：</p>
<pre><code>sudo kill -HUP &lt;parent_pid&gt;</code></pre>
<p>这会告诉父进程重新读取子进程的退出状态并释放僵尸进程。</p>
<p><img src="https://adopapa.cc/posts/backend/how-to-clean-zombie-process/images/Screenshot 2024-06-28 at 08.21.51.png" class="img-fluid"></p></li>
<li><p><strong>重启服务或系统</strong>： 如果僵尸进程是由某个服务引起的，重启该服务可能会解决问题。如果这个方法无效，重启系统通常会清理所有僵尸进程。</p>
<pre><code>sudo systemctl restart your_service
# 或者
sudo reboot</code></pre>
<h3 id="周期性监控和自动处理" data-number="3.2" class="anchored"><span class="header-section-number">3.2</span> <strong>周期性监控和自动处理</strong></h3>
<p>对于需要持续监控并处理僵尸进程的系统，可以编写脚本定期检查并处理这些进程。</p>
<ol type="1">
<li><strong>示例脚本：</strong></li>
</ol>
<pre><code>#!/bin/bash
zombies=$(ps aux | awk '{if ($8 ~ /Z/) print $2}')
if [ -n "$zombies" ]; then
    for pid in $zombies; do
        parent_pid=$(ps -o ppid= -p $pid)
        [ "$parent_pid" ] &amp;&amp; sudo kill -HUP $parent_pid
    done
fi</code></pre>
<ol start="2" type="1">
<li>设置定时任务: 将这个脚本设为定时任务，例如通过&nbsp;<code>crontab</code>&nbsp;设置定期运行。</li>
</ol>
<pre><code>crontab -e
# 添加以下行每小时运行一次脚本
0 * * * * /path/to/your/script.sh</code></pre></li>
</ol>
</section>
</section>
<section id="小结" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="小结"><span class="header-section-number">4</span> <strong>小结</strong></h2>
<p>虽然僵尸进程本身并不会消耗大量资源，但它们积累过多可能会影响系统的稳健性。通过上面的步骤，你可以识别并处理僵尸进程，确保系统保持健康的运行状态。通常，出现一个僵尸进程并不危险，但在生产环境中应尽早处理以保持系统的清洁和高效运行。</p>


</section>

 ]]></description>
  <category>linux ubuntu process zombie</category>
  <guid>https://adopapa.cc/posts/backend/how-to-clean-zombie-process/</guid>
  <pubDate>Fri, 28 Jun 2024 00:20:48 GMT</pubDate>
</item>
<item>
  <title>nginx docker 初体验</title>
  <dc:creator>metacell </dc:creator>
  <link>https://adopapa.cc/posts/backend/how-to-setup-nginx-with-docker/</link>
  <description><![CDATA[ 




<section id="上回书" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="上回书"><span class="header-section-number">1</span> 上回书</h2>
<p>ubuntu 安装了</p>
<p>ssh设置好了</p>
<p>docker安装了了</p>
<p>nginx的镜像拉取了</p>
<p>是时候把</p>
</section>
<section id="本地测试一下" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="本地测试一下"><span class="header-section-number">2</span> 本地测试一下</h2>
<p>文本内容都在本地，刚后docker也不得不安装了，就测试一下好了。</p>
<p>localwww &lt;- “~/Projects/adopapablog/_site”</p>
<p>docker run –name myblodg -v /~/Projects/adopapablog/_site:/usr/share/nginx/html:ro -d nginx</p>
<blockquote class="blockquote">
<p>1a91bd54593599aadb15ae8c04ce4446e151ba930da365eea338e07a06618d22 docker: Error response from daemon: Mounts denied: The path /~/Projects/adopapablog/_site is not shared from the host and is not known to Docker. You can configure shared paths from Docker -&gt; Preferences… -&gt; Resources -&gt; File Sharing. See <a href="https://docs.docker.com/desktop/mac" class="uri">https://docs.docker.com/desktop/mac</a> for more info.</p>
</blockquote>
<p>看来没有设置共享文件夹，按提示设置吧。</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://adopapa.cc/posts/backend/how-to-setup-nginx-with-docker/docker-resource-file-shareing.png" class="img-fluid figure-img"></p>
<figcaption>设置页面</figcaption>
</figure>
</div>
<p>居然把这个目录都设置为共享了，太过了，删除掉，但是不明白为什么这个设置了还是无法访问，可能是出在<code>～</code>上，</p>
<p>节外生枝的发现</p>
<p>quarto render 必须在项目目录下运行才有效</p>
<p>文件必须保存了才会被render否则还是上一版内容 图片的文件路径为什么要放在一起</p>
<p>扯得太远了，赶紧收回来，继续命令，不过把～替换掉</p>
<p>docker run –name myblodg -v /Users/yourname/Projects/myblogsite/_site:/usr/share/nginx/html:ro -d nginx</p>
<p>新的问题继续出现了</p>
<blockquote class="blockquote">
<p>docker: Error response from daemon: Conflict. The container name “/myblodg” is already in use by container “1a91bd54593599aadb15ae8c04ce4446e151ba930da365eea338e07a06618d22”. You have to remove (or rename) that container to be able to reuse that name. See ‘docker run –help’.</p>
</blockquote>
<p>在docker里删除即可，继续，还是上面的老问题，可能`_site`这个文件夹太诡异了，于是把它复制到～/public/myblog下</p>
<p>docker.app却像抽风了，怎么也打不开了。原来</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://adopapa.cc/posts/backend/how-to-setup-nginx-with-docker/docker-menu.png" class="img-fluid figure-img"></p>
<figcaption>docker-shortcuts-menu</figcaption>
</figure>
</div>
<p><img src="https://adopapa.cc/posts/backend/how-to-setup-nginx-with-docker/images/file-sharing-setup.png" class="img-fluid"> 图片也可以直接拖入，然后被设置到images文件夹里了。</p>
<p>修正了文件名的大小写users -&gt; Users, public -&gt; Public</p>
<p>如何去访问呢？</p>
<p>http://localhost:8080/ 显示无法访问。</p>
<p>docker exec -it myblog sh</p>
<p>cd /usr/share/nginx/html</p>
<p>ls</p>
<p><img src="https://adopapa.cc/posts/backend/how-to-setup-nginx-with-docker/images/docker-myblog-mount-status.png" class="img-fluid"></p>
<p>看来文件确实别正确地挂载上去了哈。</p>
<p>再翻回来试试</p>
<p>docker run –name myblodg -v /Users/yourname/Projects/myblogsite/_site:/usr/share/nginx/html:ro -d nginx</p>
<p>结果ok，file sharing的折腾搞一段路了。</p>
<p>d ## Dockerfiles</p>
<p>这个文件夹该放哪里呢，项目文件夹下，终于又回到了项目里了</p>
<p>在项目文件夹下运行</p>
<p>docker build -t myblog-nginx .</p>
<p>出现了一堆问题，扔给ai，它认为是Dockerfile里使用了绝对路径导致的。Docker 构建过程中，COPY 指令只能访问构建上下文中的相对路径。</p>
<p><img src="https://adopapa.cc/posts/backend/how-to-setup-nginx-with-docker/images/project-folder-structure.png" class="img-fluid"></p>
<p>docker build -t myblog-nginx .` 继续构建自己的第一个订制nginx docker image，果然OK了。</p>
<p>成功构建镜像后，运行容器：</p>
<blockquote class="blockquote">
<p>docker run –name myblog -d myblog-nginx</p>
</blockquote>
<p><img src="https://adopapa.cc/posts/backend/how-to-setup-nginx-with-docker/images/myfirst-docker-containers.png" class="img-fluid"></p>
<p>虽然什么都没有，还是感觉尽头十足啊。</p>
<p>接下来该暴露端口了，</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode zsh code-with-copy"><code class="sourceCode zsh"><span id="cb1-1"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">docker</span> run <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">--name</span> myblogsite <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-d</span> <span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">-p</span> 8080:80 myblog-nginx</span>
<span id="cb1-2"><span class="ex" style="color: null;
background-color: null;
font-style: inherit;">open</span> http://localhost:8080</span></code></pre></div>
<p>网站如约出现了，怎么刚写的文字没有出现呢，赶紧保存后用quarto render一下，看看页面还是没有更新，看来要在docker里重启一下myblogsite？ 重启后还是依然故我，看来这个不像quarto preview那么有及时预览的功能。真正的原因是之前的版本被固化到了镜像里，它完全不知道我的开发目录里发生的新变化。</p>
<p>明天继续吧，通过实战把一些长久以来都比较混淆的概念夯实了一下，当人没有ai帮助，确实是无法实现这个目标的。</p>


</section>

 ]]></description>
  <category>linux</category>
  <category>ubuntu</category>
  <category>docker</category>
  <guid>https://adopapa.cc/posts/backend/how-to-setup-nginx-with-docker/</guid>
  <pubDate>Thu, 27 Jun 2024 12:49:43 GMT</pubDate>
</item>
</channel>
</rss>
